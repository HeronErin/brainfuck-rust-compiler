extern crate llvm_sys as llvm;
#[allow(dead_code, unused)]
use std::ffi::CStr;
use std::iter;
use std::mem;

use llvm::core::*;
use llvm::execution_engine::*;
use llvm::target::*;
use llvm::LLVMBasicBlock;
use llvm::LLVMBuilder;
use llvm::LLVMContext;
use llvm::LLVMValue;
const STACK_SIZE: u64 = 4;
const input: &str = "<->";

fn dcount(test_str: &str, match_to: char) -> u64 {
    let mut r = 0;
    for c in test_str.chars() {
        if c != match_to {
            break;
        }
        r += 1;
    }
    r
}

unsafe fn gen(
    builder: *mut LLVMBuilder,
    context: *mut LLVMContext,
    current_fuc: *mut LLVMValue,
    block: *mut LLVMBasicBlock,
) {
    // Used to keep track of labels for conditionals (lifo stack)
    let mut cond_starts: Vec<*mut LLVMBasicBlock> = Vec::new();
    let mut cond_ends: Vec<*mut LLVMBasicBlock> = Vec::new();

    // og_array = malloc(STACK_SIZE)
    let og_data_ptr = LLVMBuildMalloc(
        builder,
        LLVMArrayType2(LLVMInt8Type(), STACK_SIZE),
        "arr\0".as_ptr() as *const _,
    );

    // Fill og_array with zeros
    LLVMBuildMemSet(
        builder,
        og_data_ptr,
        LLVMConstInt(LLVMInt8Type(), 0, 0),
        LLVMConstInt(LLVMInt32Type(), STACK_SIZE, 0),
        1,
    );

    // Allocate diff as an i32
    let diff_mem = LLVMBuildAlloca(builder, LLVMInt32Type(), "diff_ptr\0".as_ptr() as *const _);
    // *diff_mem = 0
    LLVMBuildStore(builder, LLVMConstInt(LLVMInt32Type(), 0, 0), diff_mem);

    // Allocate data_ptr as i8*
    let data_ptr_ptr = LLVMBuildAlloca(
        builder,
        LLVMPointerType(LLVMInt8Type(), 0),
        "data_ptr\0".as_ptr() as *const _,
    );
    // data_ptr* = og_data_ptr
    LLVMBuildStore(builder, og_data_ptr, data_ptr_ptr);

    let getTruePtr = || {
        LLVMBuildLoad2(
            builder,
            LLVMPointerType(LLVMInt8Type(), 0),
            data_ptr_ptr,
            "data_ptr_ptr_temp\0".as_ptr() as *const _,
        )
    };

    let mut index = 0;
    while index < input.len() {
        let cchar = &input[index..index + 1];
        match cchar {
            "+" | "-" => {
                let amount = dcount(&input[index..], cchar.chars().next().unwrap());
                index += amount as usize;
                let truePtr = getTruePtr();
                let currentByte = LLVMBuildLoad2(
                    builder,
                    LLVMInt8Type(),
                    truePtr,
                    "add_or_sub_temp\0".as_ptr() as *const _,
                );
                LLVMBuildStore(
                    builder,
                    if cchar == "+" {
                        LLVMBuildAdd(
                            builder,
                            currentByte,
                            LLVMConstInt(LLVMInt8Type(), amount, 0),
                            "add_tmp\0".as_ptr() as *const _,
                        )
                    } else {
                        LLVMBuildSub(
                            builder,
                            currentByte,
                            LLVMConstInt(LLVMInt8Type(), amount, 0),
                            "sub_tmp\0".as_ptr() as *const _,
                        )
                    },
                    truePtr,
                );
            }
            ">" | "<" => {
                let amount = dcount(&input[index..], cchar.chars().next().unwrap());
                index += amount as usize;
                let diff = LLVMBuildLoad2(
                    builder,
                    LLVMInt32Type(),
                    diff_mem,
                    "diff_val\0".as_ptr() as *const _,
                );
                let diff = LLVMBuildURem(
                    builder,
                    if cchar == ">" {
                        LLVMBuildAdd(
                            builder,
                            diff,
                            LLVMConstInt(LLVMInt32Type(), amount, 0),
                            "diff_add\0".as_ptr() as *const _,
                        )
                    } else {
                        LLVMBuildSub(
                            builder,
                            diff,
                            LLVMConstInt(LLVMInt32Type(), amount, 0),
                            "diff_sub\0".as_ptr() as *const _,
                        )
                    },
                    LLVMConstInt(LLVMInt32Type(), STACK_SIZE, 0),
                    "urem_ptr_temp\0".as_ptr() as *const _,
                );
                LLVMPtr
                LLVMBuildStore(builder, diff, diff_mem);
                LLVMBuildStore(
                    builder,
                    LLVMBuildAdd(
                        builder,
                        og_data_ptr, diff,
                        "inc_og_ptr_tmp\0".as_ptr() as *const _,
                    ),
                    data_ptr_ptr,
                );
            }
            _ => {
                index += 1;
            }
        }
    }

    LLVMBuildRet(builder, og_data_ptr);
}

fn main() {
    unsafe {
        // Set up a context, module and builder in that context.
        let context = LLVMContextCreate();
        LLVM_InitializeNativeTarget();
        let module =
            LLVMModuleCreateWithNameInContext(b"BrainFucked\0".as_ptr() as *const _, context);
        let builder = LLVMCreateBuilderInContext(context);

        let function = LLVMAddFunction(
            module,
            b"bf\0".as_ptr() as *const _,
            LLVMFunctionType(LLVMPointerType(LLVMInt8Type(), 0), [].as_mut_ptr(), 0, 0),
        );

        let bb = LLVMAppendBasicBlockInContext(context, function, b"entry\0".as_ptr() as *const _);

        LLVMPositionBuilderAtEnd(builder, bb);

        gen(builder, context, function, bb);

        LLVMDisposeBuilder(builder);
        LLVMDumpModule(module);

        LLVMLinkInMCJIT();

        LLVM_InitializeNativeAsmPrinter();

        // Build an execution engine.
        let ee = {
            let mut ee = mem::MaybeUninit::uninit();
            let mut err = mem::zeroed();

            // This moves ownership of the module into the execution engine.
            if LLVMCreateExecutionEngineForModule(ee.as_mut_ptr(), module, &mut err) != 0 {
                // In case of error, we must avoid using the uninitialized ExecutionEngineRef.
                assert!(!err.is_null());
                panic!(
                    "Failed to create execution engine: {:?}",
                    CStr::from_ptr(err)
                );
            }

            ee.assume_init()
        };
        let addr = LLVMGetFunctionAddress(ee, b"bf\0".as_ptr() as *const _);
        let f: extern "C" fn() -> *mut u8 = mem::transmute(addr);
        let a = f();
        let v = Vec::from_raw_parts(a, STACK_SIZE as usize, STACK_SIZE as usize);
        println!("Got {:?}", &v);
        println!("Addr {}", f as usize);

        LLVMDisposeExecutionEngine(ee);
        LLVMContextDispose(context);
    }
}
